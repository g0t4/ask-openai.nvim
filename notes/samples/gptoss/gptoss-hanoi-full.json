{"choices":[{"finish_reason":"stop","index":0,"message":{"role":"assistant","content":"<|channel|>analysis<|message|>We need to give code for Tower of Hanoi in Lua. Likely explain algorithm, provide recursive function, maybe interactive. Provide explanation, code snippet. Also maybe include table representation of pegs, print moves. Provide full script. Let's produce.<|start|>assistant<|channel|>final<|message|>Below is a **complete, self‑contained Lua program** that solves the classic Tower of Hanoi puzzle.  \nIt is written in idiomatic Lua 5.3+ (works on Lua 5.1/5.2 as well) and is designed to be read, modified, or dropped into a REPL or script file.\n\n---\n\n## 1.  What the program does\n\n* Accepts a command‑line argument for the number of disks (default = 3).  \n* Uses three stacks (`P1`, `P2`, `P3`) represented as Lua tables.  \n* Recursively moves all disks from `P1` to `P3` while obeying the classic rules:  \n  * Only one disk may be moved at a time.  \n  * A larger disk may never be placed on top of a smaller one.  \n* Prints every move in the form  \n\n```\nMove disk X from P1 to P3\n```\n\n* After finishing, it prints the total number of moves and the minimal theoretical number (`2^n‑1`) for comparison.\n\n---\n\n## 2.  The code\n\n```lua\n-- tower_of_hanoi.lua\n-- ---------------------------------------------------------------\n--  Tower of Hanoi solver in pure Lua\n-- ---------------------------------------------------------------\n\n-- ------------------------------------------------------------------\n-- Helper: print usage and exit\n-- ------------------------------------------------------------------\nlocal function usage()\n    io.write([[\nUsage: lua tower_of_hanoi.lua [num_disks]\n\n  num_disks   Optional. Number of disks (must be a positive integer).\n              Default = 3.\n\n]])\n    os.exit(1)\nend\n\n-- ------------------------------------------------------------------\n-- Parse command‑line argument\n-- ------------------------------------------------------------------\nlocal argc = #arg\nlocal n     -- number of disks\n\nif argc == 0 then\n    n = 3\nelseif argc == 1 then\n    n = tonumber(arg[1])\n    if not n or n <= 0 or math.floor(n) ~= n then\n        io.stderr:write(\"Error: num_disks must be a positive integer.\\n\")\n        usage()\n    end\nelse\n    usage()\nend\n\n-- ------------------------------------------------------------------\n-- Data structure: each peg is a table used as a stack.\n-- The top of the stack is the last element (table[#t]).\n-- ------------------------------------------------------------------\nlocal Peg = { P1 = {}, P2 = {}, P3 = {} }\n\n-- Initialize Peg.P1 with disks n .. 1 (largest at bottom)\nfor disk = n, 1, -1 do\n    table.insert(Peg.P1, disk)\nend\n\n-- ------------------------------------------------------------------\n-- Utility: print the current state of the pegs (optional debugging)\n-- ------------------------------------------------------------------\nlocal function dump_pegs()\n    for name, peg in pairs(Peg) do\n        io.write(string.format(\"%s: %s\\n\", name, table.concat(peg, \" \")))\n    end\nend\n\n-- ------------------------------------------------------------------\n-- Recursive Hanoi solver\n-- ------------------------------------------------------------------\nlocal move_count = 0\n\n--- move a disk from one peg to another\nlocal function move_disk(src, dst)\n    local disk = table.remove(src)   -- pop from source\n    table.insert(dst, disk)          -- push onto destination\n    move_count = move_count + 1\n    print(string.format(\"Move disk %d from %s to %s\",\n                        disk,\n                        src.name, dst.name))\nend\n\n--- recursive helper\nlocal function hanoi(k, source, spare, target)\n    if k == 0 then\n        return\n    end\n    hanoi(k - 1, source, target, spare)\n    move_disk(source, target)\n    hanoi(k - 1, spare, source, target)\nend\n\n-- Attach names to peg tables for pretty printing\nPeg.P1.name = \"P1\"\nPeg.P2.name = \"P2\"\nPeg.P3.name = \"P3\"\n\n-- ------------------------------------------------------------------\n-- Run the algorithm\n-- ------------------------------------------------------------------\nprint(string.format(\"Solving Tower of Hanoi with %d disk(s)...\", n))\nhanoi(n, Peg.P1, Peg.P2, Peg.P3)\n\nprint(\"\\nAll disks are now on P3.\")\nprint(string.format(\"Total moves performed: %d\", move_count))\nprint(string.format(\"Minimal moves (2^%d - 1): %d\", n, 2^n - 1))\n```\n\n### How to run\n\n```bash\n# Default (3 disks)\nlua tower_of_hanoi.lua\n\n# 5 disks\nlua tower_of_hanoi.lua 5\n```\n\nThe script prints each individual move.  \nYou can comment out or remove the `print(...)` inside `move_disk` if you only want the final count.\n\n---\n\n## 3.  How the algorithm works (brief recap)\n\nThe recursive algorithm follows the classic pattern:\n\n```\nHanoi(k, src, aux, dst):\n    if k == 0: return\n    Hanoi(k-1, src, dst, aux)   -- move k-1 disks to auxiliary\n    move one disk from src to dst\n    Hanoi(k-1, aux, src, dst)   -- move k-1 disks onto dst\n```\n\nThe base case `k == 0` stops the recursion.  \nEach recursive call reduces the problem size by one, guaranteeing termination after exactly `2^n - 1` moves.\n\n---\n\n## 4.  Extending / Tweaking\n\n* **Visualizing the pegs** – uncomment `dump_pegs()` after each move to see the state.  \n* **Different pegs order** – change the order of arguments in `hanoi(n, Peg.P1, Peg.P2, Peg.P3)` to solve to a different target peg.  \n* **Iterative solution** – replace the recursive part with an explicit stack if you need an iterative implementation.  \n\nHappy coding, and enjoy the elegance of this classic puzzle!"}}],"created":1754514919,"model":"gpt-3.5-turbo","system_fingerprint":"b6097-9515c613","object":"chat.completion","usage":{"completion_tokens":1273,"prompt_tokens":88,"total_tokens":1361},"id":"chatcmpl-VVndNuuKdhJBRHuBA8NS1pOIcTOxNE2x","timings":{"prompt_n":88,"prompt_ms":63.486,"prompt_per_token_ms":0.7214318181818181,"prompt_per_second":1386.1323756418738,"predicted_n":1273,"predicted_ms":4751.155,"predicted_per_token_ms":3.7322505891594657,"predicted_per_second":267.93484952606264}}
